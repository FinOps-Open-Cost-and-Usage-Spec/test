name: Log Project Field Change
on:
  repository_dispatch:
    types: [project_field_updated]

jobs:
  comment_change:
    runs-on: ubuntu-latest
    steps:
      - name: Fetch Current State
        id: fetch_state
        env:
          GH_TOKEN: ${{ secrets.PROJECT_PAT }}
          # Pathing based on the payload you provided
          ITEM_ID: ${{ github.event.client_payload.projects_v2_item.node_id }}
          FIELD_NAME: ${{ github.event.client_payload.changes.field_value.field_name }}
        run: |
          set -e
          echo "Waiting 5s for API sync..."
          sleep 5

          read -r -d '' QUERY << 'EOF' || true
          query($item_id: ID!, $field_name: String!) {
            node(id: $item_id) {
              ... on ProjectV2Item {
                fieldValueByName(name: $field_name) {
                  ... on ProjectV2ItemFieldSingleSelectValue { name }
                  ... on ProjectV2ItemFieldTextValue { text }
                  ... on ProjectV2ItemFieldDateValue { date }
                }
              }
            }
          }
          EOF

          QUERY_DATA=$(gh api graphql -f query="$QUERY" -f item_id="$ITEM_ID" -f field_name="$FIELD_NAME")
          
          # Extract the NEW value from the API
          RAW_NEW_VAL=$(echo "$QUERY_DATA" | jq -r '.data.node.fieldValueByName | (.name // .text // .date // "None")')
          echo "NEW_VAL_CLEAN=${RAW_NEW_VAL%%T*}" >> $GITHUB_ENV

      - name: Post Comment (as Bot)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_ID: ${{ github.event.client_payload.projects_v2_item.content_node_id }}
          FIELD: ${{ github.event.client_payload.changes.field_value.field_name }}
          # Pass the 'from' data as a JSON string to handle both objects and primitives
          FROM_JSON: ${{ toJson(github.event.client_payload.changes.field_value.from) }}
          USER_LOGIN: ${{ github.event.client_payload.sender.login }}
        run: |
          set -e
          
          # 1. Process the "From" value using jq logic
          # If it's an object, get .name or .text or .date. 
          # If it's a string/number, use it as is.
          # If it's null, return "None".
          FINAL_OLD=$(echo "$FROM_JSON" | jq -r '
            if type == "object" then 
              (.name // .text // .date // "None")
            elif type == "null" then 
              "None"
            else 
              . 
            end
          ')

          # 2. Final Trimming and formatting
          FINAL_OLD="${FINAL_OLD%%T*}"
          FINAL_NEW="${NEW_VAL_CLEAN:-None}"

          # Clean up literal "null" strings
          [ "$FINAL_NEW" == "null" ] && FINAL_NEW="None"
          [ "$FINAL_OLD" == "null" ] || [ -z "$FINAL_OLD" ] && FINAL_OLD="None"

          # 3. Suppress if no change (Race condition handling)
          if [ "$FINAL_NEW" == "$FINAL_OLD" ]; then
            echo "No visible change ($FINAL_OLD -> $FINAL_NEW). Skipping."
            exit 0
          fi

          # 4. Post the comment
          COMMENT_BODY="ðŸ”„ **$USER_LOGIN** updated **$FIELD**: $FINAL_OLD â†’ **$FINAL_NEW**"
          
          gh api graphql -f query='
            mutation($id: ID!, $body: String!) {
              addComment(input: {subjectId: $id, body: $body}) { clientMutationId }
            }' -f id="$ISSUE_ID" -f body="$COMMENT_BODY"
