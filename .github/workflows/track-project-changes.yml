name: Log Project Field Change
on:
  repository_dispatch:
    types: [project_field_updated]

jobs:
  comment_change:
    runs-on: ubuntu-latest
    steps:
      - name: Extract Variables and Fetch State
        id: process
        env:
          GH_TOKEN: ${{ secrets.PROJECT_PAT }}
          # Pass the entire event to a file so we can find the data anywhere
          EVENT_JSON: ${{ toJson(github.event.client_payload) }}
        run: |
          set -e

          # 1. Use jq to find the values regardless of where they are nested
          # This looks for node_id and content_node_id anywhere in the payload
          ITEM_ID=$(echo "$EVENT_JSON" | jq -r '.. | .node_id? // empty' | head -n 1)
          ISSUE_ID=$(echo "$EVENT_JSON" | jq -r '.. | .content_node_id? // empty' | head -n 1)
          FIELD_NAME=$(echo "$EVENT_JSON" | jq -r '.. | .field_name? // empty' | head -n 1)
          USER_LOGIN=$(echo "$EVENT_JSON" | jq -r '.. | .login? // empty' | head -n 1)
          
          # Extract the 'from' value as a JSON string for later processing
          FROM_JSON=$(echo "$EVENT_JSON" | jq -c '.. | .from? // empty' | head -n 1)

          if [ -z "$ITEM_ID" ] || [ "$ITEM_ID" == "null" ]; then
            echo "Error: Could not find node_id in the payload."
            echo "Debug Payload: $EVENT_JSON"
            exit 1
          fi

          echo "Found ITEM_ID: $ITEM_ID"
          echo "Waiting 5s for API sync..."
          sleep 5

          # 2. Query GitHub for the NEW state
          read -r -d '' QUERY << 'EOF' || true
          query($item_id: ID!, $field_name: String!) {
            node(id: $item_id) {
              ... on ProjectV2Item {
                fieldValueByName(name: $field_name) {
                  ... on ProjectV2ItemFieldSingleSelectValue { name }
                  ... on ProjectV2ItemFieldTextValue { text }
                  ... on ProjectV2ItemFieldDateValue { date }
                }
              }
            }
          }
          EOF

          QUERY_DATA=$(gh api graphql -f query="$QUERY" -f item_id="$ITEM_ID" -f field_name="$FIELD_NAME")
          
          # Extract and clean NEW value
          RAW_NEW_VAL=$(echo "$QUERY_DATA" | jq -r '.data.node.fieldValueByName | if type == "object" then (.name // .text // .date // "None") else "None" end')
          CLEAN_NEW="${RAW_NEW_VAL%%T*}"
          CLEAN_NEW="${CLEAN_NEW%%+*}"

          # 3. Process OLD value
          FINAL_OLD=$(echo "$FROM_JSON" | jq -r '
            if type == "object" then (.name // .text // .date // "None")
            elif type == "string" then .
            else "None" end
          ')
          FINAL_OLD="${FINAL_OLD%%T*}"
          FINAL_OLD="${FINAL_OLD%%+*}"

          # Save everything to environment for the final step
          {
            echo "FINAL_NEW=${CLEAN_NEW:-None}"
            echo "FINAL_OLD=${FINAL_OLD:-None}"
            echo "ISSUE_ID=$ISSUE_ID"
            echo "FIELD_NAME=$FIELD_NAME"
            echo "USER_LOGIN=$USER_LOGIN"
          } >> "$GITHUB_ENV"

      - name: Post Comment (as Bot)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          
          # Clean literal "null" strings
          [ "$FINAL_NEW" == "null" ] && FINAL_NEW="None"
          [ "$FINAL_OLD" == "null" ] && FINAL_OLD="None"

          if [ "$FINAL_NEW" == "$FINAL_OLD" ]; then
            echo "No change detected ($FINAL_OLD -> $FINAL_NEW). Skipping."
            exit 0
          fi

          COMMENT_BODY="ðŸ”„ **$USER_LOGIN** updated **$FIELD_NAME**: $FINAL_OLD â†’ **$FINAL_NEW**"
          
          gh api graphql -f query='
            mutation($id: ID!, $body: String!) {
              addComment(input: {subjectId: $id, body: $body}) { clientMutationId }
            }' -f id="$ISSUE_ID" -f body="$COMMENT_BODY"
